/**
 * Utils.gs - RSS Feeder ユーティリティ関数
 * 日付処理、マークダウン生成、データ変換等の共通機能
 */

/**
 * 現在の日付をYYYY-MM-DD形式で取得する
 * @return {string} YYYY-MM-DD形式の日付文字列
 */
function getCurrentDateString() {
  const today = new Date();
  return formatDateString(today);
}

/**
 * DateオブジェクトをYYYY-MM-DD形式で変換する
 * @param {Date} date - 変換するDateオブジェクト
 * @return {string} YYYY-MM-DD形式の日付文字列
 */
function formatDateString(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

/**
 * 日本時間での現在時刻を取得する
 * @return {Date} 日本時間のDateオブジェクト
 */
function getJapanTime() {
  const now = new Date();
  const japanOffset = 9 * 60; // JST is UTC+9
  const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
  return new Date(utc + (japanOffset * 60000));
}

/**
 * タグ文字列を階層構造に分解する
 * @param {string} tagString - カンマ区切りのタグ文字列 (例: "tech/ai, tech/web")
 * @return {Array<Object>} タグオブジェクトの配列
 */
function parseTagString(tagString) {
  if (!tagString || typeof tagString !== 'string') {
    return [];
  }
  
  const tags = [];
  const tagParts = tagString.split(',').map(tag => tag.trim());
  
  tagParts.forEach(tag => {
    if (tag) {
      const parts = tag.split('/');
      const tagObj = {
        full: tag,
        category: parts[0] || '',
        subcategory: parts[1] || '',
        hierarchy: parts
      };
      tags.push(tagObj);
    }
  });
  
  return tags;
}

/**
 * タグに基づいてファイルパスを生成する
 * @param {string} tag - タグ文字列 (例: "tech/ai")
 * @param {string} date - 日付文字列 (例: "2025-06-28")
 * @return {string} ファイルパス (例: "RSS/2025-06-28/tech/ai.md")
 */
function generateFilePath(tag, date) {
  const outputDir = getOutputDirectory();
  const tagPath = tag.replace(/\//g, '/');
  return `${outputDir}/${date}/${tagPath}.md`;
}

/**
 * タグに基づいてディレクトリパスを生成する
 * @param {string} tag - タグ文字列 (例: "tech/ai")
 * @param {string} date - 日付文字列 (例: "2025-06-28")
 * @return {string} ディレクトリパス (例: "RSS/2025-06-28/tech/")
 */
function generateDirectoryPath(tag, date) {
  const outputDir = getOutputDirectory();
  const tagParts = tag.split('/');
  
  if (tagParts.length > 1) {
    // サブカテゴリがある場合、その親ディレクトリまで
    const parentPath = tagParts.slice(0, -1).join('/');
    return `${outputDir}/${date}/${parentPath}/`;
  } else {
    // サブカテゴリがない場合、日付ディレクトリまで
    return `${outputDir}/${date}/`;
  }
}

/**
 * マークダウンファイルのYAMLフロントマターを生成する
 * @param {string} tag - タグ文字列
 * @param {number} articleCount - 記事数
 * @param {string} date - 日付文字列
 * @return {string} YAMLフロントマター
 */
function generateYamlFrontmatter(tag, articleCount, date) {
  const tagParts = tag.split('/');
  const tags = ['daily-digest'];
  
  // 階層タグを配列に追加
  tagParts.forEach(part => {
    if (part && !tags.includes(part)) {
      tags.push(part);
    }
  });
  
  const frontmatter = [
    '---',
    `date: ${date}`,
    `tag: ${tag}`,
    `article_count: ${articleCount}`,
    `created_by: RSS Feeder`,
    'tags:',
    ...tags.map(t => `  - ${t}`),
    '---',
    ''
  ];
  
  return frontmatter.join('\n');
}

/**
 * マークダウンファイルの本文を生成する
 * @param {string} tag - タグ文字列
 * @param {Array<RssArticle>} articles - 記事配列
 * @param {string} summary - AI生成の要約
 * @param {string} date - 日付文字列
 * @return {string} マークダウン本文
 */
function generateMarkdownContent(tag, articles, summary, date) {
  const tagName = convertTagToJapanese(tag);
  const content = [];
  
  // タイトル
  content.push(`# ${tagName}関連記事まとめ (${date})`);
  content.push('');
  
  // 要約セクション
  if (summary) {
    content.push('## 要約');
    content.push(summary);
    content.push('');
  }
  
  // 記事一覧セクション
  content.push('## 記事一覧');
  articles.forEach(article => {
    const title = escapeMarkdown(article.title);
    const url = article.link;
    const feedTitle = escapeMarkdown(article.feedTitle);
    content.push(`- [${title}](${url}) - ${feedTitle}`);
  });
  content.push('');
  
  // 詳細セクション（記事が複数ある場合）
  if (articles.length > 1) {
    content.push('## 詳細');
    
    // フィード別にグループ化
    const articlesByFeed = groupArticlesByFeed(articles);
    
    Object.entries(articlesByFeed).forEach(([feedTitle, feedArticles]) => {
      content.push(`### ${escapeMarkdown(feedTitle)}`);
      feedArticles.forEach(article => {
        const title = escapeMarkdown(article.title);
        const url = article.link;
        content.push(`- [${title}](${url})`);
        if (article.description) {
          const description = escapeMarkdown(article.description);
          content.push(`  ${description.substring(0, 200)}...`);
        }
      });
      content.push('');
    });
  }
  
  // フッター
  content.push('---');
  content.push(`*Generated by RSS Feeder on ${date}*`);
  
  return content.join('\n');
}

/**
 * タグを日本語表示名に変換する
 * @param {string} tag - タグ文字列 (例: "tech/ai")
 * @return {string} 日本語表示名 (例: "AI技術")
 */
function convertTagToJapanese(tag) {
  const tagMapping = {
    'tech': 'テクノロジー',
    'tech/ai': 'AI技術',
    'tech/web': 'Web技術',
    'tech/mobile': 'モバイル技術',
    'tech/cloud': 'クラウド技術',
    'cryptography': '暗号学',
    'security': 'セキュリティ',
    'business': 'ビジネス',
    'business/startup': 'スタートアップ',
    'business/finance': '金融',
    'science': '科学',
    'programming': 'プログラミング',
    'data': 'データ分析',
    'design': 'デザイン',
    'marketing': 'マーケティング'
  };
  
  return tagMapping[tag] || tag;
}

/**
 * マークダウン特殊文字をエスケープする
 * @param {string} text - エスケープするテキスト
 * @return {string} エスケープ済みテキスト
 */
function escapeMarkdown(text) {
  if (!text || typeof text !== 'string') {
    return '';
  }
  
  return text
    .replace(/\\/g, '\\\\')
    .replace(/\[/g, '\\[')
    .replace(/\]/g, '\\]')
    .replace(/\(/g, '\\(')
    .replace(/\)/g, '\\)')
    .replace(/\*/g, '\\*')
    .replace(/_/g, '\\_')
    .replace(/`/g, '\\`')
    .replace(/#/g, '\\#')
    .replace(/\|/g, '\\|');
}

/**
 * 記事をフィード別にグループ化する
 * @param {Array<RssArticle>} articles - 記事配列
 * @return {Object} フィード別記事オブジェクト
 */
function groupArticlesByFeed(articles) {
  const grouped = {};
  
  articles.forEach(article => {
    const feedTitle = article.feedTitle || 'その他';
    if (!grouped[feedTitle]) {
      grouped[feedTitle] = [];
    }
    grouped[feedTitle].push(article);
  });
  
  return grouped;
}

/**
 * 記事をタグ別にグループ化する
 * @param {Array<Object>} taggedArticles - タグ付き記事配列
 * @return {Object} タグ別記事オブジェクト
 */
function groupArticlesByTag(taggedArticles) {
  const grouped = {};
  
  taggedArticles.forEach(item => {
    const { article, tags } = item;
    
    if (tags && tags.length > 0) {
      tags.forEach(tag => {
        if (!grouped[tag]) {
          grouped[tag] = [];
        }
        grouped[tag].push(article);
      });
    } else {
      // タグなしの記事は 'other' に分類
      if (!grouped['other']) {
        grouped['other'] = [];
      }
      grouped['other'].push(article);
    }
  });
  
  return grouped;
}

/**
 * 配列をバッチに分割する
 * @param {Array} array - 分割する配列
 * @param {number} batchSize - バッチサイズ
 * @return {Array<Array>} バッチ配列
 */
function splitIntoBatches(array, batchSize) {
  const batches = [];
  
  for (let i = 0; i < array.length; i += batchSize) {
    batches.push(array.slice(i, i + batchSize));
  }
  
  return batches;
}

/**
 * 文字列の長さを制限する
 * @param {string} text - 制限するテキスト
 * @param {number} maxLength - 最大文字数
 * @param {string} suffix - 切り詰め時の接尾辞（デフォルト: '...'）
 * @return {string} 制限後のテキスト
 */
function truncateText(text, maxLength, suffix = '...') {
  if (!text || typeof text !== 'string') {
    return '';
  }
  
  if (text.length <= maxLength) {
    return text;
  }
  
  return text.substring(0, maxLength - suffix.length) + suffix;
}

/**
 * URLが有効かどうかを検証する
 * @param {string} url - 検証するURL
 * @return {boolean} 有効性
 */
function isValidUrl(url) {
  if (!url || typeof url !== 'string') {
    return false;
  }
  
  try {
    new URL(url);
    return url.startsWith('http://') || url.startsWith('https://');
  } catch (error) {
    return false;
  }
}

/**
 * 重複を除去した配列を返す
 * @param {Array} array - 重複除去する配列
 * @param {Function} keyFunction - キー抽出関数（オプション）
 * @return {Array} 重複除去後の配列
 */
function removeDuplicates(array, keyFunction = null) {
  if (!Array.isArray(array)) {
    return [];
  }
  
  if (keyFunction) {
    const seen = new Set();
    return array.filter(item => {
      const key = keyFunction(item);
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  } else {
    return [...new Set(array)];
  }
}

/**
 * エラーメッセージを日本語でフォーマットする
 * @param {string} context - エラーコンテキスト
 * @param {Error|string} error - エラーオブジェクトまたはメッセージ
 * @return {string} フォーマット済みエラーメッセージ
 */
function formatError(context, error) {
  const timestamp = getJapanTime().toLocaleString('ja-JP');
  const errorMessage = error instanceof Error ? error.toString() : String(error);
  
  return `[${timestamp}] ${context}: ${errorMessage}`;
}

/**
 * パフォーマンス測定用のタイマー
 * @param {string} label - タイマーラベル
 * @return {Function} 停止関数
 */
function startTimer(label) {
  const startTime = Date.now();
  console.log(`⏱️ ${label} 開始`);
  
  return function stopTimer() {
    const endTime = Date.now();
    const duration = endTime - startTime;
    console.log(`⏱️ ${label} 完了: ${duration}ms`);
    return duration;
  };
}

/**
 * ユーティリティ関数のテスト
 */
function testUtils() {
  console.log('=== Utils テスト開始 ===');
  
  try {
    // 日付関数テスト
    const dateStr = getCurrentDateString();
    console.log(`現在日付: ${dateStr}`);
    
    // タグ解析テスト
    const tags = parseTagString('tech/ai, tech/web, cryptography');
    console.log(`タグ解析結果:`, tags);
    
    // パス生成テスト
    const filePath = generateFilePath('tech/ai', dateStr);
    const dirPath = generateDirectoryPath('tech/ai', dateStr);
    console.log(`ファイルパス: ${filePath}`);
    console.log(`ディレクトリパス: ${dirPath}`);
    
    // フロントマター生成テスト
    const frontmatter = generateYamlFrontmatter('tech/ai', 5, dateStr);
    console.log('フロントマター:');
    console.log(frontmatter);
    
    // URL検証テスト
    console.log('URL検証:', isValidUrl('https://example.com'));
    console.log('無効URL検証:', isValidUrl('invalid-url'));
    
    // 重複除去テスト
    const duplicates = ['a', 'b', 'a', 'c', 'b'];
    const unique = removeDuplicates(duplicates);
    console.log(`重複除去: [${duplicates.join(', ')}] → [${unique.join(', ')}]`);
    
  } catch (error) {
    console.error('テストエラー:', error.toString());
  }
  
  console.log('=== Utils テスト完了 ===');
}